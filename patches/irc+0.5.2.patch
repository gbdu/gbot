diff --git a/node_modules/irc/lib/irc.js b/node_modules/irc/lib/irc.js
index 23ccfe0..f28d6e2 100644
--- a/node_modules/irc/lib/irc.js
+++ b/node_modules/irc/lib/irc.js
@@ -58,9 +58,9 @@ function Client(server, nick, opt) {
         messageSplit: 512,
         encoding: false,
         webirc: {
-          pass: '',
-          ip: '',
-          host: ''
+            pass: '',
+            ip: '',
+            host: ''
         },
         millisecondsOfSilenceBeforePingSent: 15 * 1000,
         millisecondsBeforePingTimeout: 8 * 1000
@@ -116,539 +116,539 @@ function Client(server, nick, opt) {
             to;
 
         switch (message.command) {
-            case 'rpl_welcome':
-                // Set nick to whatever the server decided it really is
-                // (normally this is because you chose something too long and
-                // the server has shortened it
-                self.nick = message.args[0];
-                // Note our hostmask to use it in splitting long messages.
-                // We don't send our hostmask when issuing PRIVMSGs or NOTICEs,
-                // of course, but rather the servers on the other side will
-                // include it in messages and will truncate what we send if
-                // the string is too long. Therefore, we need to be considerate
-                // neighbors and truncate our messages accordingly.
-                var welcomeStringWords = message.args[1].split(/\s+/);
-                self.hostMask = welcomeStringWords[welcomeStringWords.length - 1];
+        case 'rpl_welcome':
+            // Set nick to whatever the server decided it really is
+            // (normally this is because you chose something too long and
+            // the server has shortened it
+            self.nick = message.args[0];
+            // Note our hostmask to use it in splitting long messages.
+            // We don't send our hostmask when issuing PRIVMSGs or NOTICEs,
+            // of course, but rather the servers on the other side will
+            // include it in messages and will truncate what we send if
+            // the string is too long. Therefore, we need to be considerate
+            // neighbors and truncate our messages accordingly.
+            var welcomeStringWords = message.args[1].split(/\s+/);
+            self.hostMask = welcomeStringWords[welcomeStringWords.length - 1];
+            self._updateMaxLineLength();
+            self.emit('registered', message);
+            self.whois(self.nick, function(args) {
+                self.nick = args.nick;
+                self.hostMask = args.user + '@' + args.host;
                 self._updateMaxLineLength();
-                self.emit('registered', message);
-                self.whois(self.nick, function(args) {
-                    self.nick = args.nick;
-                    self.hostMask = args.user + '@' + args.host;
-                    self._updateMaxLineLength();
-                });
-                break;
-            case 'rpl_myinfo':
-                self.supported.usermodes = message.args[3];
-                break;
-            case 'rpl_isupport':
-                message.args.forEach(function(arg) {
-                    var match;
-                    match = arg.match(/([A-Z]+)=(.*)/);
-                    if (match) {
-                        var param = match[1];
-                        var value = match[2];
-                        switch (param) {
-                            case 'CHANLIMIT':
-                                value.split(',').forEach(function(val) {
-                                    val = val.split(':');
-                                    self.supported.channel.limit[val[0]] = parseInt(val[1]);
-                                });
-                                break;
-                            case 'CHANMODES':
-                                value = value.split(',');
-                                var type = ['a', 'b', 'c', 'd'];
-                                for (var i = 0; i < type.length; i++) {
-                                    self.supported.channel.modes[type[i]] += value[i];
-                                }
-                                break;
-                            case 'CHANTYPES':
-                                self.supported.channel.types = value;
-                                break;
-                            case 'CHANNELLEN':
-                                self.supported.channel.length = parseInt(value);
-                                break;
-                            case 'IDCHAN':
-                                value.split(',').forEach(function(val) {
-                                    val = val.split(':');
-                                    self.supported.channel.idlength[val[0]] = val[1];
-                                });
-                                break;
-                            case 'KICKLEN':
-                                self.supported.kicklength = value;
-                                break;
-                            case 'MAXLIST':
-                                value.split(',').forEach(function(val) {
-                                    val = val.split(':');
-                                    self.supported.maxlist[val[0]] = parseInt(val[1]);
-                                });
-                                break;
-                            case 'NICKLEN':
-                                self.supported.nicklength = parseInt(value);
-                                break;
-                            case 'PREFIX':
-                                match = value.match(/\((.*?)\)(.*)/);
-                                if (match) {
-                                    match[1] = match[1].split('');
-                                    match[2] = match[2].split('');
-                                    while (match[1].length) {
-                                        self.modeForPrefix[match[2][0]] = match[1][0];
-                                        self.supported.channel.modes.b += match[1][0];
-                                        self.prefixForMode[match[1].shift()] = match[2].shift();
-                                    }
-                                }
-                                break;
-                            case 'STATUSMSG':
-                                break;
-                            case 'TARGMAX':
-                                value.split(',').forEach(function(val) {
-                                    val = val.split(':');
-                                    val[1] = (!val[1]) ? 0 : parseInt(val[1]);
-                                    self.supported.maxtargets[val[0]] = val[1];
-                                });
-                                break;
-                            case 'TOPICLEN':
-                                self.supported.topiclength = parseInt(value);
-                                break;
+            });
+            break;
+        case 'rpl_myinfo':
+            self.supported.usermodes = message.args[3];
+            break;
+        case 'rpl_isupport':
+            message.args.forEach(function(arg) {
+                var match;
+                match = arg.match(/([A-Z]+)=(.*)/);
+                if (match) {
+                    var param = match[1];
+                    var value = match[2];
+                    switch (param) {
+                    case 'CHANLIMIT':
+                        value.split(',').forEach(function(val) {
+                            val = val.split(':');
+                            self.supported.channel.limit[val[0]] = parseInt(val[1]);
+                        });
+                        break;
+                    case 'CHANMODES':
+                        value = value.split(',');
+                        var type = ['a', 'b', 'c', 'd'];
+                        for (var i = 0; i < type.length; i++) {
+                            self.supported.channel.modes[type[i]] += value[i];
                         }
+                        break;
+                    case 'CHANTYPES':
+                        self.supported.channel.types = value;
+                        break;
+                    case 'CHANNELLEN':
+                        self.supported.channel.length = parseInt(value);
+                        break;
+                    case 'IDCHAN':
+                        value.split(',').forEach(function(val) {
+                            val = val.split(':');
+                            self.supported.channel.idlength[val[0]] = val[1];
+                        });
+                        break;
+                    case 'KICKLEN':
+                        self.supported.kicklength = value;
+                        break;
+                    case 'MAXLIST':
+                        value.split(',').forEach(function(val) {
+                            val = val.split(':');
+                            self.supported.maxlist[val[0]] = parseInt(val[1]);
+                        });
+                        break;
+                    case 'NICKLEN':
+                        self.supported.nicklength = parseInt(value);
+                        break;
+                    case 'PREFIX':
+                        match = value.match(/\((.*?)\)(.*)/);
+                        if (match) {
+                            match[1] = match[1].split('');
+                            match[2] = match[2].split('');
+                            while (match[1].length) {
+                                self.modeForPrefix[match[2][0]] = match[1][0];
+                                self.supported.channel.modes.b += match[1][0];
+                                self.prefixForMode[match[1].shift()] = match[2].shift();
+                            }
+                        }
+                        break;
+                    case 'STATUSMSG':
+                        break;
+                    case 'TARGMAX':
+                        value.split(',').forEach(function(val) {
+                            val = val.split(':');
+                            val[1] = (!val[1]) ? 0 : parseInt(val[1]);
+                            self.supported.maxtargets[val[0]] = val[1];
+                        });
+                        break;
+                    case 'TOPICLEN':
+                        self.supported.topiclength = parseInt(value);
+                        break;
                     }
-                });
-                break;
-            case 'rpl_yourhost':
-            case 'rpl_created':
-            case 'rpl_luserclient':
-            case 'rpl_luserop':
-            case 'rpl_luserchannels':
-            case 'rpl_luserme':
-            case 'rpl_localusers':
-            case 'rpl_globalusers':
-            case 'rpl_statsconn':
-            case 'rpl_luserunknown':
-            case '396':
-            case '042':
-                // Random welcome crap, ignoring
-                break;
-            case 'err_nicknameinuse':
-                if (typeof (self.opt.nickMod) == 'undefined')
-                    self.opt.nickMod = 0;
-                self.opt.nickMod++;
-                self.send('NICK', self.opt.nick + self.opt.nickMod);
-                self.nick = self.opt.nick + self.opt.nickMod;
-                self._updateMaxLineLength();
-                break;
-            case 'PING':
-                self.send('PONG', message.args[0]);
-                self.emit('ping', message.args[0]);
-                break;
-            case 'PONG':
-                self.emit('pong', message.args[0]);
+                }
+            });
+            break;
+        case 'rpl_yourhost':
+        case 'rpl_created':
+        case 'rpl_luserclient':
+        case 'rpl_luserop':
+        case 'rpl_luserchannels':
+        case 'rpl_luserme':
+        case 'rpl_localusers':
+        case 'rpl_globalusers':
+        case 'rpl_statsconn':
+        case 'rpl_luserunknown':
+        case '396':
+        case '042':
+            // Random welcome crap, ignoring
+            break;
+        case 'err_nicknameinuse':
+            if (typeof (self.opt.nickMod) == 'undefined')
+                self.opt.nickMod = 0;
+            self.opt.nickMod++;
+            self.send('NICK', self.opt.nick + self.opt.nickMod);
+            self.nick = self.opt.nick + self.opt.nickMod;
+            self._updateMaxLineLength();
+            break;
+        case 'PING':
+            self.send('PONG', message.args[0]);
+            self.emit('ping', message.args[0]);
+            break;
+        case 'PONG':
+            self.emit('pong', message.args[0]);
+            break;
+        case 'NOTICE':
+            from = message.nick;
+            to = message.args[0];
+            if (!to) {
+                to = null;
+            }
+            text = message.args[1] || '';
+            if (text[0] === '\u0001' && text.lastIndexOf('\u0001') > 0) {
+                self._handleCTCP(from, to, text, 'notice', message);
                 break;
-            case 'NOTICE':
-                from = message.nick;
-                to = message.args[0];
-                if (!to) {
-                    to = null;
+            }
+            self.emit('notice', from, to, text, message);
+
+            if (self.opt.debug && to == self.nick)
+                util.log('GOT NOTICE from ' + (from ? '"' + from + '"' : 'the server') + ': "' + text + '"');
+            break;
+        case 'MODE':
+            if (self.opt.debug)
+                util.log('MODE: ' + message.args[0] + ' sets mode: ' + message.args[1]);
+
+            channel = self.chanData(message.args[0]);
+            if (!channel) break;
+            var modeList = message.args[1].split('');
+            var adding = true;
+            var modeArgs = message.args.slice(2);
+            modeList.forEach(function(mode) {
+                if (mode == '+') {
+                    adding = true;
+                    return;
                 }
-                text = message.args[1] || '';
-                if (text[0] === '\u0001' && text.lastIndexOf('\u0001') > 0) {
-                    self._handleCTCP(from, to, text, 'notice', message);
-                    break;
+                if (mode == '-') {
+                    adding = false;
+                    return;
                 }
-                self.emit('notice', from, to, text, message);
 
-                if (self.opt.debug && to == self.nick)
-                    util.log('GOT NOTICE from ' + (from ? '"' + from + '"' : 'the server') + ': "' + text + '"');
-                break;
-            case 'MODE':
-                if (self.opt.debug)
-                    util.log('MODE: ' + message.args[0] + ' sets mode: ' + message.args[1]);
-
-                channel = self.chanData(message.args[0]);
-                if (!channel) break;
-                var modeList = message.args[1].split('');
-                var adding = true;
-                var modeArgs = message.args.slice(2);
-                modeList.forEach(function(mode) {
-                    if (mode == '+') {
-                        adding = true;
-                        return;
-                    }
-                    if (mode == '-') {
-                        adding = false;
-                        return;
-                    }
-
-                    var eventName = (adding ? '+' : '-') + 'mode';
-                    var supported = self.supported.channel.modes;
-                    var modeArg;
-                    var chanModes = function(mode, param) {
-                        var arr = param && Array.isArray(param);
-                        if (adding) {
-                            if (channel.mode.indexOf(mode) == -1) {
-                                channel.mode += mode;
-                            }
-                            if (param === undefined) {
-                                channel.modeParams[mode] = [];
-                            } else if (arr) {
-                                channel.modeParams[mode] = channel.modeParams[mode] ?
-                                    channel.modeParams[mode].concat(param) : param;
-                            } else {
-                                channel.modeParams[mode] = [param];
-                            }
+                var eventName = (adding ? '+' : '-') + 'mode';
+                var supported = self.supported.channel.modes;
+                var modeArg;
+                var chanModes = function(mode, param) {
+                    var arr = param && Array.isArray(param);
+                    if (adding) {
+                        if (channel.mode.indexOf(mode) == -1) {
+                            channel.mode += mode;
+                        }
+                        if (param === undefined) {
+                            channel.modeParams[mode] = [];
+                        } else if (arr) {
+                            channel.modeParams[mode] = channel.modeParams[mode] ?
+                                channel.modeParams[mode].concat(param) : param;
                         } else {
-                            if (arr) {
-                                channel.modeParams[mode] = channel.modeParams[mode]
-                                    .filter(function(v) { return v !== param[0]; });
-                            }
-                            if (!arr || channel.modeParams[mode].length === 0) {
-                                channel.mode = channel.mode.replace(mode, '');
-                                delete channel.modeParams[mode];
-                            }
+                            channel.modeParams[mode] = [param];
+                        }
+                    } else {
+                        if (arr) {
+                            channel.modeParams[mode] = channel.modeParams[mode]
+                                .filter(function(v) { return v !== param[0]; });
                         }
-                    };
-                    if (mode in self.prefixForMode) {
-                        modeArg = modeArgs.shift();
-                        if (channel.users.hasOwnProperty(modeArg)) {
-                            if (adding) {
-                                if (channel.users[modeArg].indexOf(self.prefixForMode[mode]) === -1)
-                                    channel.users[modeArg] += self.prefixForMode[mode];
-                            } else channel.users[modeArg] = channel.users[modeArg].replace(self.prefixForMode[mode], '');
+                        if (!arr || channel.modeParams[mode].length === 0) {
+                            channel.mode = channel.mode.replace(mode, '');
+                            delete channel.modeParams[mode];
                         }
-                        self.emit(eventName, message.args[0], message.nick, mode, modeArg, message);
-                    } else if (supported.a.indexOf(mode) !== -1) {
-                        modeArg = modeArgs.shift();
-                        chanModes(mode, [modeArg]);
-                        self.emit(eventName, message.args[0], message.nick, mode, modeArg, message);
-                    } else if (supported.b.indexOf(mode) !== -1) {
-                        modeArg = modeArgs.shift();
-                        chanModes(mode, modeArg);
-                        self.emit(eventName, message.args[0], message.nick, mode, modeArg, message);
-                    } else if (supported.c.indexOf(mode) !== -1) {
-                        if (adding) modeArg = modeArgs.shift();
-                        else modeArg = undefined;
-                        chanModes(mode, modeArg);
-                        self.emit(eventName, message.args[0], message.nick, mode, modeArg, message);
-                    } else if (supported.d.indexOf(mode) !== -1) {
-                        chanModes(mode);
-                        self.emit(eventName, message.args[0], message.nick, mode, undefined, message);
                     }
-                });
-                break;
-            case 'NICK':
-                if (message.nick == self.nick) {
-                    // the user just changed their own nick
-                    self.nick = message.args[0];
-                    self._updateMaxLineLength();
+                };
+                if (mode in self.prefixForMode) {
+                    modeArg = modeArgs.shift();
+                    if (channel.users.hasOwnProperty(modeArg)) {
+                        if (adding) {
+                            if (channel.users[modeArg].indexOf(self.prefixForMode[mode]) === -1)
+                                channel.users[modeArg] += self.prefixForMode[mode];
+                        } else channel.users[modeArg] = channel.users[modeArg].replace(self.prefixForMode[mode], '');
+                    }
+                    self.emit(eventName, message.args[0], message.nick, mode, modeArg, message);
+                } else if (supported.a.indexOf(mode) !== -1) {
+                    modeArg = modeArgs.shift();
+                    chanModes(mode, modeArg);
+                    self.emit(eventName, message.args[0], message.nick, mode, modeArg, message);
+                } else if (supported.b.indexOf(mode) !== -1) {
+                    modeArg = modeArgs.shift();
+                    chanModes(mode, modeArg);
+                    self.emit(eventName, message.args[0], message.nick, mode, modeArg, message);
+                } else if (supported.c.indexOf(mode) !== -1) {
+                    if (adding) modeArg = modeArgs.shift();
+                    else modeArg = undefined;
+                    chanModes(mode, modeArg);
+                    self.emit(eventName, message.args[0], message.nick, mode, modeArg, message);
+                } else if (supported.d.indexOf(mode) !== -1) {
+                    chanModes(mode);
+                    self.emit(eventName, message.args[0], message.nick, mode, undefined, message);
                 }
+            });
+            break;
+        case 'NICK':
+            if (message.nick == self.nick) {
+                // the user just changed their own nick
+                self.nick = message.args[0];
+                self._updateMaxLineLength();
+            }
 
-                if (self.opt.debug)
-                    util.log('NICK: ' + message.nick + ' changes nick to ' + message.args[0]);
+            if (self.opt.debug)
+                util.log('NICK: ' + message.nick + ' changes nick to ' + message.args[0]);
 
-                channels = [];
+            channels = [];
 
-                // TODO better way of finding what channels a user is in?
-                Object.keys(self.chans).forEach(function(channame) {
-                    var channel = self.chans[channame];
-                    channel.users[message.args[0]] = channel.users[message.nick];
-                    delete channel.users[message.nick];
-                    channels.push(channame);
-                });
+            // TODO better way of finding what channels a user is in?
+            Object.keys(self.chans).forEach(function(channame) {
+                var channel = self.chans[channame];
+                channel.users[message.args[0]] = channel.users[message.nick];
+                delete channel.users[message.nick];
+                channels.push(channame);
+            });
 
-                // old nick, new nick, channels
-                self.emit('nick', message.nick, message.args[0], channels, message);
-                break;
-            case 'rpl_motdstart':
-                self.motd = message.args[1] + '\n';
-                break;
-            case 'rpl_motd':
-                self.motd += message.args[1] + '\n';
-                break;
-            case 'rpl_endofmotd':
-            case 'err_nomotd':
-                self.motd += message.args[1] + '\n';
-                self.emit('motd', self.motd);
-                break;
-            case 'rpl_namreply':
-                channel = self.chanData(message.args[2]);
-                var users = message.args[3].trim().split(/ +/);
-                if (channel) {
-                    users.forEach(function(user) {
-                        var match = user.match(/^(.)(.*)$/);
-                        if (match) {
-                            if (match[1] in self.modeForPrefix) {
-                                channel.users[match[2]] = match[1];
-                            }
-                            else {
-                                channel.users[match[1] + match[2]] = '';
-                            }
+            // old nick, new nick, channels
+            self.emit('nick', message.nick, message.args[0], channels, message);
+            break;
+        case 'rpl_motdstart':
+            self.motd = message.args[1] + '\n';
+            break;
+        case 'rpl_motd':
+            self.motd += message.args[1] + '\n';
+            break;
+        case 'rpl_endofmotd':
+        case 'err_nomotd':
+            self.motd += message.args[1] + '\n';
+            self.emit('motd', self.motd);
+            break;
+        case 'rpl_namreply':
+            channel = self.chanData(message.args[2]);
+            var users = message.args[3].trim().split(/ +/);
+            if (channel) {
+                users.forEach(function(user) {
+                    var match = user.match(/^(.)(.*)$/);
+                    if (match) {
+                        if (match[1] in self.modeForPrefix) {
+                            channel.users[match[2]] = match[1];
                         }
-                    });
-                }
-                break;
-            case 'rpl_endofnames':
-                channel = self.chanData(message.args[1]);
-                if (channel) {
-                    self.emit('names', message.args[1], channel.users);
-                    self.emit('names' + message.args[1], channel.users);
-                    self.send('MODE', message.args[1]);
-                }
-                break;
-            case 'rpl_topic':
-                channel = self.chanData(message.args[1]);
-                if (channel) {
-                    channel.topic = message.args[2];
-                }
-                break;
-            case 'rpl_away':
-                self._addWhoisData(message.args[1], 'away', message.args[2], true);
-                break;
-            case 'rpl_whoisuser':
-                self._addWhoisData(message.args[1], 'user', message.args[2]);
-                self._addWhoisData(message.args[1], 'host', message.args[3]);
-                self._addWhoisData(message.args[1], 'realname', message.args[5]);
-                break;
-            case 'rpl_whoisidle':
-                self._addWhoisData(message.args[1], 'idle', message.args[2]);
-                break;
-            case 'rpl_whoischannels':
-               // TODO - clean this up?
-                self._addWhoisData(message.args[1], 'channels', message.args[2].trim().split(/\s+/));
-                break;
-            case 'rpl_whoisserver':
-                self._addWhoisData(message.args[1], 'server', message.args[2]);
-                self._addWhoisData(message.args[1], 'serverinfo', message.args[3]);
-                break;
-            case 'rpl_whoisoperator':
-                self._addWhoisData(message.args[1], 'operator', message.args[2]);
-                break;
-            case '330': // rpl_whoisaccount?
-                self._addWhoisData(message.args[1], 'account', message.args[2]);
-                self._addWhoisData(message.args[1], 'accountinfo', message.args[3]);
-                break;
-            case 'rpl_endofwhois':
-                self.emit('whois', self._clearWhoisData(message.args[1]));
-                break;
-            case 'rpl_whoreply':
-                self._addWhoisData(message.args[5], 'user', message.args[2]);
-                self._addWhoisData(message.args[5], 'host', message.args[3]);
-                self._addWhoisData(message.args[5], 'server', message.args[4]);
-                self._addWhoisData(message.args[5], 'realname', /[0-9]+\s*(.+)/g.exec(message.args[7])[1]);
-                // emit right away because rpl_endofwho doesn't contain nick
-                self.emit('whois', self._clearWhoisData(message.args[5]));
-                break;
-            case 'rpl_liststart':
-                self.channellist = [];
-                self.emit('channellist_start');
-                break;
-            case 'rpl_list':
-                channel = {
-                    name: message.args[1],
-                    users: message.args[2],
-                    topic: message.args[3]
-                };
-                self.emit('channellist_item', channel);
-                self.channellist.push(channel);
-                break;
-            case 'rpl_listend':
-                self.emit('channellist', self.channellist);
-                break;
-            case 'rpl_topicwhotime':
-                channel = self.chanData(message.args[1]);
-                if (channel) {
-                    channel.topicBy = message.args[2];
-                    // channel, topic, nick
-                    self.emit('topic', message.args[1], channel.topic, channel.topicBy, message);
-                }
-                break;
-            case 'TOPIC':
+                        else {
+                            channel.users[match[1] + match[2]] = '';
+                        }
+                    }
+                });
+            }
+            break;
+        case 'rpl_endofnames':
+            channel = self.chanData(message.args[1]);
+            if (channel) {
+                self.emit('names', message.args[1], channel.users);
+                self.emit('names' + message.args[1], channel.users);
+                self.send('MODE', message.args[1]);
+            }
+            break;
+        case 'rpl_topic':
+            channel = self.chanData(message.args[1]);
+            if (channel) {
+                channel.topic = message.args[2];
+            }
+            break;
+        case 'rpl_away':
+            self._addWhoisData(message.args[1], 'away', message.args[2], true);
+            break;
+        case 'rpl_whoisuser':
+            self._addWhoisData(message.args[1], 'user', message.args[2]);
+            self._addWhoisData(message.args[1], 'host', message.args[3]);
+            self._addWhoisData(message.args[1], 'realname', message.args[5]);
+            break;
+        case 'rpl_whoisidle':
+            self._addWhoisData(message.args[1], 'idle', message.args[2]);
+            break;
+        case 'rpl_whoischannels':
+            // TODO - clean this up?
+            self._addWhoisData(message.args[1], 'channels', message.args[2].trim().split(/\s+/));
+            break;
+        case 'rpl_whoisserver':
+            self._addWhoisData(message.args[1], 'server', message.args[2]);
+            self._addWhoisData(message.args[1], 'serverinfo', message.args[3]);
+            break;
+        case 'rpl_whoisoperator':
+            self._addWhoisData(message.args[1], 'operator', message.args[2]);
+            break;
+        case '330': // rpl_whoisaccount?
+            self._addWhoisData(message.args[1], 'account', message.args[2]);
+            self._addWhoisData(message.args[1], 'accountinfo', message.args[3]);
+            break;
+        case 'rpl_endofwhois':
+            self.emit('whois', self._clearWhoisData(message.args[1]));
+            break;
+        case 'rpl_whoreply':
+            self._addWhoisData(message.args[5], 'user', message.args[2]);
+            self._addWhoisData(message.args[5], 'host', message.args[3]);
+            self._addWhoisData(message.args[5], 'server', message.args[4]);
+            self._addWhoisData(message.args[5], 'realname', /[0-9]+\s*(.+)/g.exec(message.args[7])[1]);
+            // emit right away because rpl_endofwho doesn't contain nick
+            self.emit('whois', self._clearWhoisData(message.args[5]));
+            break;
+        case 'rpl_liststart':
+            self.channellist = [];
+            self.emit('channellist_start');
+            break;
+        case 'rpl_list':
+            channel = {
+                name: message.args[1],
+                users: message.args[2],
+                topic: message.args[3]
+            };
+            self.emit('channellist_item', channel);
+            self.channellist.push(channel);
+            break;
+        case 'rpl_listend':
+            self.emit('channellist', self.channellist);
+            break;
+        case 'rpl_topicwhotime':
+            channel = self.chanData(message.args[1]);
+            if (channel) {
+                channel.topicBy = message.args[2];
                 // channel, topic, nick
-                self.emit('topic', message.args[0], message.args[1], message.nick, message);
-
+                self.emit('topic', message.args[1], channel.topic, channel.topicBy, message);
+            }
+            break;
+        case 'TOPIC':
+            // channel, topic, nick
+            self.emit('topic', message.args[0], message.args[1], message.nick, message);
+
+            channel = self.chanData(message.args[0]);
+            if (channel) {
+                channel.topic = message.args[1];
+                channel.topicBy = message.nick;
+            }
+            break;
+        case 'rpl_channelmodeis':
+            channel = self.chanData(message.args[1]);
+            if (channel) {
+                channel.mode = message.args[2];
+            }
+            break;
+        case 'rpl_creationtime':
+            channel = self.chanData(message.args[1]);
+            if (channel) {
+                channel.created = message.args[2];
+            }
+            break;
+        case 'JOIN':
+            // channel, who
+            if (self.nick == message.nick) {
+                self.chanData(message.args[0], true);
+            }
+            else {
                 channel = self.chanData(message.args[0]);
-                if (channel) {
-                    channel.topic = message.args[1];
-                    channel.topicBy = message.nick;
-                }
-                break;
-            case 'rpl_channelmodeis':
-                channel = self.chanData(message.args[1]);
-                if (channel) {
-                    channel.mode = message.args[2];
-                }
-                break;
-            case 'rpl_creationtime':
-                channel = self.chanData(message.args[1]);
-                if (channel) {
-                    channel.created = message.args[2];
-                }
-                break;
-            case 'JOIN':
-                // channel, who
-                if (self.nick == message.nick) {
-                    self.chanData(message.args[0], true);
-                }
-                else {
-                    channel = self.chanData(message.args[0]);
-                    if (channel && channel.users) {
-                        channel.users[message.nick] = '';
-                    }
-                }
-                self.emit('join', message.args[0], message.nick, message);
-                self.emit('join' + message.args[0], message.nick, message);
-                if (message.args[0] != message.args[0].toLowerCase()) {
-                    self.emit('join' + message.args[0].toLowerCase(), message.nick, message);
-                }
-                break;
-            case 'PART':
-                // channel, who, reason
-                self.emit('part', message.args[0], message.nick, message.args[1], message);
-                self.emit('part' + message.args[0], message.nick, message.args[1], message);
-                if (message.args[0] != message.args[0].toLowerCase()) {
-                    self.emit('part' + message.args[0].toLowerCase(), message.nick, message.args[1], message);
+                if (channel && channel.users) {
+                    channel.users[message.nick] = '';
                 }
-                if (self.nick == message.nick) {
-                    channel = self.chanData(message.args[0]);
-                    delete self.chans[channel.key];
-                }
-                else {
-                    channel = self.chanData(message.args[0]);
-                    if (channel && channel.users) {
-                        delete channel.users[message.nick];
-                    }
-                }
-                break;
-            case 'KICK':
-                // channel, who, by, reason
-                self.emit('kick', message.args[0], message.args[1], message.nick, message.args[2], message);
-                self.emit('kick' + message.args[0], message.args[1], message.nick, message.args[2], message);
-                if (message.args[0] != message.args[0].toLowerCase()) {
-                    self.emit('kick' + message.args[0].toLowerCase(),
-                              message.args[1], message.nick, message.args[2], message);
+            }
+            self.emit('join', message.args[0], message.nick, message);
+            self.emit('join' + message.args[0], message.nick, message);
+            if (message.args[0] != message.args[0].toLowerCase()) {
+                self.emit('join' + message.args[0].toLowerCase(), message.nick, message);
+            }
+            break;
+        case 'PART':
+            // channel, who, reason
+            self.emit('part', message.args[0], message.nick, message.args[1], message);
+            self.emit('part' + message.args[0], message.nick, message.args[1], message);
+            if (message.args[0] != message.args[0].toLowerCase()) {
+                self.emit('part' + message.args[0].toLowerCase(), message.nick, message.args[1], message);
+            }
+            if (self.nick == message.nick) {
+                channel = self.chanData(message.args[0]);
+                delete self.chans[channel.key];
+            }
+            else {
+                channel = self.chanData(message.args[0]);
+                if (channel && channel.users) {
+                    delete channel.users[message.nick];
                 }
+            }
+            break;
+        case 'KICK':
+            // channel, who, by, reason
+            self.emit('kick', message.args[0], message.args[1], message.nick, message.args[2], message);
+            self.emit('kick' + message.args[0], message.args[1], message.nick, message.args[2], message);
+            if (message.args[0] != message.args[0].toLowerCase()) {
+                self.emit('kick' + message.args[0].toLowerCase(),
+                    message.args[1], message.nick, message.args[2], message);
+            }
 
-                if (self.nick == message.args[1]) {
-                    channel = self.chanData(message.args[0]);
-                    delete self.chans[channel.key];
-                }
-                else {
-                    channel = self.chanData(message.args[0]);
-                    if (channel && channel.users) {
-                        delete channel.users[message.args[1]];
-                    }
+            if (self.nick == message.args[1]) {
+                channel = self.chanData(message.args[0]);
+                delete self.chans[channel.key];
+            }
+            else {
+                channel = self.chanData(message.args[0]);
+                if (channel && channel.users) {
+                    delete channel.users[message.args[1]];
                 }
+            }
+            break;
+        case 'KILL':
+            nick = message.args[0];
+            channels = [];
+            Object.keys(self.chans).forEach(function(channame) {
+                var channel = self.chans[channame];
+                channels.push(channame);
+                delete channel.users[nick];
+            });
+            self.emit('kill', nick, message.args[1], channels, message);
+            break;
+        case 'PRIVMSG':
+            from = message.nick;
+            to = message.args[0];
+            text = message.args[1] || '';
+            if (text[0] === '\u0001' && text.lastIndexOf('\u0001') > 0) {
+                self._handleCTCP(from, to, text, 'privmsg', message);
                 break;
-            case 'KILL':
-                nick = message.args[0];
-                channels = [];
-                Object.keys(self.chans).forEach(function(channame) {
-                    var channel = self.chans[channame];
-                    channels.push(channame);
-                    delete channel.users[nick];
-                });
-                self.emit('kill', nick, message.args[1], channels, message);
-                break;
-            case 'PRIVMSG':
-                from = message.nick;
-                to = message.args[0];
-                text = message.args[1] || '';
-                if (text[0] === '\u0001' && text.lastIndexOf('\u0001') > 0) {
-                    self._handleCTCP(from, to, text, 'privmsg', message);
-                    break;
-                }
-                self.emit('message', from, to, text, message);
-                if (self.supported.channel.types.indexOf(to.charAt(0)) !== -1) {
-                    self.emit('message#', from, to, text, message);
-                    self.emit('message' + to, from, text, message);
-                    if (to != to.toLowerCase()) {
-                        self.emit('message' + to.toLowerCase(), from, text, message);
-                    }
+            }
+            self.emit('message', from, to, text, message);
+            if (self.supported.channel.types.indexOf(to.charAt(0)) !== -1) {
+                self.emit('message#', from, to, text, message);
+                self.emit('message' + to, from, text, message);
+                if (to != to.toLowerCase()) {
+                    self.emit('message' + to.toLowerCase(), from, text, message);
                 }
-                if (to.toUpperCase() === self.nick.toUpperCase()) self.emit('pm', from, text, message);
-
-                if (self.opt.debug && to == self.nick)
-                    util.log('GOT MESSAGE from ' + from + ': ' + text);
-                break;
-            case 'INVITE':
-                from = message.nick;
-                to = message.args[0];
-                channel = message.args[1];
-                self.emit('invite', channel, from, message);
+            }
+            if (to.toUpperCase() === self.nick.toUpperCase()) self.emit('pm', from, text, message);
+
+            if (self.opt.debug && to == self.nick)
+                util.log('GOT MESSAGE from ' + from + ': ' + text);
+            break;
+        case 'INVITE':
+            from = message.nick;
+            to = message.args[0];
+            channel = message.args[1];
+            self.emit('invite', channel, from, message);
+            break;
+        case 'QUIT':
+            if (self.opt.debug)
+                util.log('QUIT: ' + message.prefix + ' ' + message.args.join(' '));
+            if (self.nick == message.nick) {
+                // TODO handle?
                 break;
-            case 'QUIT':
-                if (self.opt.debug)
-                    util.log('QUIT: ' + message.prefix + ' ' + message.args.join(' '));
-                if (self.nick == message.nick) {
-                    // TODO handle?
-                    break;
-                }
-                // handle other people quitting
+            }
+            // handle other people quitting
 
-                channels = [];
+            channels = [];
 
-                // TODO better way of finding what channels a user is in?
-                Object.keys(self.chans).forEach(function(channame) {
-                    var channel = self.chans[channame];
-                    delete channel.users[message.nick];
-                    channels.push(channame);
-                });
+            // TODO better way of finding what channels a user is in?
+            Object.keys(self.chans).forEach(function(channame) {
+                var channel = self.chans[channame];
+                delete channel.users[message.nick];
+                channels.push(channame);
+            });
 
-                // who, reason, channels
-                self.emit('quit', message.nick, message.args[0], channels, message);
-                break;
+            // who, reason, channels
+            self.emit('quit', message.nick, message.args[0], channels, message);
+            break;
 
             // for sasl
-            case 'CAP':
-                if (message.args[0] === '*' &&
+        case 'CAP':
+            if (message.args[0] === '*' &&
                      message.args[1] === 'ACK' &&
                      message.args[2] === 'sasl ') // there's a space after sasl
-                    self.send('AUTHENTICATE', 'PLAIN');
-                break;
-            case 'AUTHENTICATE':
-                if (message.args[0] === '+') self.send('AUTHENTICATE',
-                    new Buffer(
-                        self.opt.nick + '\0' +
+                self.send('AUTHENTICATE', 'PLAIN');
+            break;
+        case 'AUTHENTICATE':
+            if (message.args[0] === '+') self.send('AUTHENTICATE',
+                new Buffer(
+                    self.opt.nick + '\0' +
                         self.opt.userName + '\0' +
                         self.opt.password
-                    ).toString('base64'));
-                break;
-            case '903':
-                self.send('CAP', 'END');
-                break;
+                ).toString('base64'));
+            break;
+        case '903':
+            self.send('CAP', 'END');
+            break;
+
+        case 'err_umodeunknownflag':
+            if (self.opt.showErrors)
+                util.log('\u001b[01;31mERROR: ' + util.inspect(message) + '\u001b[0m');
+            break;
+
+        case 'err_erroneusnickname':
+            if (self.opt.showErrors)
+                util.log('\u001b[01;31mERROR: ' + util.inspect(message) + '\u001b[0m');
+            self.emit('error', message);
+            break;
 
-            case 'err_umodeunknownflag':
+            // Commands relating to OPER
+        case 'err_nooperhost':
+            if (self.opt.showErrors) {
+                self.emit('error', message);
                 if (self.opt.showErrors)
                     util.log('\u001b[01;31mERROR: ' + util.inspect(message) + '\u001b[0m');
-                break;
+            }
+            break;
+
+        case 'rpl_youreoper':
+            self.emit('opered');
+            break;
 
-            case 'err_erroneusnickname':
+        default:
+            if (message.commandType == 'error') {
+                self.emit('error', message);
                 if (self.opt.showErrors)
                     util.log('\u001b[01;31mERROR: ' + util.inspect(message) + '\u001b[0m');
-                self.emit('error', message);
-                break;
-
-            // Commands relating to OPER
-            case 'err_nooperhost':
-                if (self.opt.showErrors) {
-                    self.emit('error', message);
-                    if (self.opt.showErrors)
-                        util.log('\u001b[01;31mERROR: ' + util.inspect(message) + '\u001b[0m');
-                }
-                break;
-
-            case 'rpl_youreoper':
-                self.emit('opered');
+            }
+            else {
+                if (self.opt.debug)
+                    util.log('\u001b[01;31mUnhandled message: ' + util.inspect(message) + '\u001b[0m');
                 break;
-
-            default:
-                if (message.commandType == 'error') {
-                    self.emit('error', message);
-                    if (self.opt.showErrors)
-                        util.log('\u001b[01;31mERROR: ' + util.inspect(message) + '\u001b[0m');
-                }
-                else {
-                    if (self.opt.debug)
-                        util.log('\u001b[01;31mUnhandled message: ' + util.inspect(message) + '\u001b[0m');
-                    break;
-                }
+            }
         }
     });
 
